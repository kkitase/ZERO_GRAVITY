# Project: ZERO_GRAVITY

```plaintext
OS: posix
Directory: /mnt/d/Prj/ZERO_GRAVITY

├── .agent/
│   ├── rules/
│   │   ├── character-rules-seira.md
│   │   ├── japanese-rules.md
│   │   └── project_governance.md
│   └── workflows/
│       └── setup_project_agent.md
└── ANTIGRAVITY_AGENT_CONTROL_SPEC.MD
```

## 📊 プロジェクト統計

- 📅 作成日時: 2025-12-30 16:09:01
- 📁 総ディレクトリ数: 3
- 📄 総ファイル数: 5
- 📏 最大深度: 2
- 📦 最大ディレクトリ:  (8 エントリ)

### 📊 ファイルサイズと行数

| ファイル | サイズ | 行数 | 言語 |
|----------|--------|------|------|
| ANTIGRAVITY_AGENT_CONTROL_SPEC.MD | 32.0 KB | 361 | markdown |
| .agent/workflows/setup_project_agent.md | 5.1 KB | 131 | markdown |
| .agent/rules/character-rules-seira.md | 2.9 KB | 80 | markdown |
| .agent/rules/japanese-rules.md | 907.0 B | 32 | markdown |
| .agent/rules/project_governance.md | 1.1 KB | 26 | markdown |
| **合計** |  | **630** |  |

### 📈 言語別統計

| 言語 | ファイル数 | 総行数 | 合計サイズ |
|------|------------|--------|------------|
| markdown | 5 | 630 | 42.0 KB |

`ANTIGRAVITY_AGENT_CONTROL_SPEC.MD`

**サイズ**: 32.0 KB | **行数**: 361 行
```markdown
# Google Antigravityにおける高度なエージェント制御：RulesとWorkflowsの技術仕様および相互作用に関する包括的分析

## 1. エグゼクティブサマリー

2025年11月、Google Antigravityの登場は、ソフトウェア開発エコシステムにおける「AI支援（AI Assistance）」から「エージェント主導開発（Agentic Development Environment - ADE）」へのパラダイムシフトを決定づける転換点となった。従来の統合開発環境（IDE）がコード補完やチャットボットによる局所的な支援に留まっていたのに対し、AntigravityはGemini 3 ProやGemini 3 Deep Thinkといったフロンティアモデルを搭載した自律型エージェントをオーケストレーションするためのプラットフォームとして再定義されている。

本レポートは、Antigravityにおけるエージェント制御の中核を成す二つの機構、「Rules（ルール）」と「Workflows（ワークフロー）」について、その技術仕様、定義構文、およびランタイムにおける相互作用メカニズムを徹底的に解明することを目的とする。

調査の結果、Rulesはエージェントの「憲法」として機能し、永続的なコンテキスト境界と行動制約（何をすべきか、何をすべきでないか）を宣言的に定義するものであることが明らかになった。対してWorkflowsは、エージェントの「標準作業手順書（SOP）」として機能し、特定のタスクを達成するための軌道と操作ロジック（どのように動くか）を命令的に記述するものである。

これら二つの機能は独立して存在するのではなく、エージェントマネージャー（Mission Control）によって動的に統合され、高度に決定論的かつ柔軟なタスク実行を実現している。特に、Antigravityの「Model Decision（モデルによる決定）」トリガーや、ワークフロー内の「Turbo Mode（ターボモード）」といった機能は、従来のAIコーディングツールが抱えていたコンテキストの過負荷や実行速度のボトルネックを解消するための重要な技術的進歩である。

本稿では、これらの機能を活用し、開発者が単なるコーダーから、自律エージェント群を指揮するシステムアーキテクトへと役割を進化させるためのベストプラクティスを、具体的なコード例と運用フロー図を交えて提示する。

## 2. Antigravityにおけるエージェントアーキテクチャの基本概念

RulesとWorkflowsの詳細な技術仕様に踏み込む前に、それらが動作するAntigravityの基盤アーキテクチャを理解する必要がある。AntigravityはVisual Studio Codeのフォークとして構築されているが、そのメンタルモデルは根本的に異なっている。

### 2.1 コパイロットから「同僚」への進化

従来のGitHub Copilotや初期のCursorは、開発者の入力に対する「予測と補完」のループで動作していた。これに対しAntigravityは、「タスクの委任と監視」のループを採用している。開発者はコードを書くのではなく、Agent Manager（エージェントマネージャー）と呼ばれる専用のインターフェースを通じてタスク（例：「認証モジュールのリファクタリング」）を発行する。

このアーキテクチャにおいて、エージェントは以下の3つのサーフェス（操作面）を横断して自律的に活動する：

*   **Code Editor（エディタ）**: ソースコードの読み取り、書き込み、ファイル操作を行う。Gemini 3 Proの100万トークンを超えるコンテキストウィンドウにより、リポジトリ全体をメモリに保持したかのような推論が可能となる。
*   **Terminal（ターミナル）**: ビルドコマンド、テスト実行、Git操作、システムスクリプトの実行を行う。エージェントはエラー出力を解析し、自律的に修正を試みる「自己修復ループ」を持つ。
*   **Browser Subagent（ブラウザサブエージェント）**: ヘッドレス（または可視化された）Chromeインスタンスを操作し、WebアプリケーションのDOM操作、スクリーンショット撮影、セッション記録を行う。これにより、従来の単体テストでは捕捉できないUIの崩れや動的な挙動の検証が可能となる。

### 2.2 制御構造の必要性：決定論と自律性のバランス

エージェントの自律性が高まることは、同時に予測不可能性のリスクを増大させる。特にGemini 3 Deep Thinkのような推論能力の高いモデルは、指示が曖昧な場合、独創的すぎる解決策や、プロジェクトの既存規約を無視したコードを生成する可能性がある（いわゆる「幻覚」や「逸脱」）。

ここで「Rules」と「Workflows」が不可欠な制御機構として機能する。これらはLLMという「原子炉」に対する「制御棒」の役割を果たし、エージェントの出力をプロジェクトの要件に適合させるためのガードレールを提供する。

*   **Rules (宣言的制御)**: コンテキストに永続的に注入され、エージェントの判断基準を規定する。「常にType Hintsを使用せよ」「any型は禁止する」といった静的な制約。
*   **Workflows (手続き的制御)**: タスクの実行手順を規定する。「ファイルを解析し、テスト計画を立て、実装し、検証する」という一連のフロー。

次章以降で、これらの技術仕様を詳細に分解していく。

## 3. 技術詳解：Rules（ルール）機能の仕様と挙動

Google AntigravityのRulesエンジンは、単なるシステムプロンプトの拡張ではなく、大規模なコードベースに対応するための動的でコンテキスト指向の制約管理システムである。

### 3.1 定義とストレージ構造

Rulesは、ワークスペースのルートディレクトリにある `.agent/rules/` フォルダ内に格納される。従来の `.cursorrules` が単一ファイル（または少数のファイル）に依存しがちであったのに対し、Antigravityは分散型ルールアーキテクチャを推奨している。

**ディレクトリ構造のベストプラクティス**

Antigravityのプロジェクトでは、以下のような階層的なルール定義が一般的である：

```text
my-project/
├── .agent/
│   ├── rules/
│   │   ├── 00-core-architecture.md   # プロジェクト全体の基本方針
│   │   ├── 10-python-style.md        # 言語固有のスタイルガイド
│   │   ├── 20-security-policy.md     # セキュリティ要件
│   │   └── frontend/                 # フロントエンド固有のルール
│   │       ├── react-components.md
│   │       └── tailwind-usage.md
└── src/
```

この構造により、ルールの可読性と保守性が向上する。また、グローバルレベル（ユーザーのホームディレクトリ、例：`~/.gemini/GEMINI.md`）でのルール定義もサポートされており、個人の好みを反映させることも可能である。

優先順位は通常、グローバル < ワークスペース < フォルダ固有 の順で適用されるが、後述するトリガーメカニズムによって動的に制御される。

### 3.2 構文とスキーマ：YAML Frontmatterの役割

Ruleファイルの実体はMarkdownファイルであるが、その挙動を制御するのはファイル先頭の YAML Frontmatter である。ここで、そのルールが「いつ」「どのように」エージェントのコンテキストに注入されるかを定義する。

**基本構文例** (`.agent/rules/type-safety.md`)

```markdown
---
slug: type-safety
description: Pythonコードにおける型ヒントとPydanticの使用に関する厳格な基準を強制する。
trigger: always_on
---
# Type Safety Standards

このプロジェクトで生成または修正されるすべてのPythonコードは、以下の基準を満たす必要がある：

1. **完全な型アノテーション**: すべての関数シグネチャ（引数および戻り値）に型ヒントを付与すること。
2. **Anyの禁止**: `typing.Any` の使用は原則禁止とする。外部ライブラリの制約などで不可避な場合は、コメントで理由を明記すること。
3. **Pydantic V2**: データ転送オブジェクト（DTO）の定義には必ず Pydantic V2 を使用し、ConfigDict で `strict=True` を設定すること。
```

### 3.3 トリガーメカニズム：コンテキストウィンドウの最適化

Antigravityの最大の技術的特長の一つが、高度なトリガーシステムである。巨大なモノレポにおいて、すべてのルールを常にコンテキストに含めることは、トークンコストの浪費であり、モデルの注意力を散漫にさせる原因となる。Antigravityは4つのトリガータイプによってこれを解決している。

以下の表は、各トリガータイプの技術的特性をまとめたものである。

| トリガータイプ | 定義構文 (`trigger:`) | 動作メカニズム | 推奨ユースケース |
| :--- | :--- | :--- | :--- |
| **Always On** | `always_on` | エージェントの初期化時にシステムプロンプトの一部として無条件に注入される。 | プロジェクト全体のアーキテクチャ原則、禁止事項、コーディングスタイルの基礎。 |
| **Manual** | `manual` | ユーザーがチャット内で `@rule-name` の形式で明示的にメンションした場合のみロードされる。 | 頻度の低い特定のタスク（例：DBマイグレーション、大規模リファクタリング、監査）。 |
| **Glob Pattern** | glob | 編集中のファイルパスや、タスクに関連するファイル群が指定されたGlobパターン（例：`**/*.tsx`）にマッチした場合に自動的にロードされる。 | 言語固有のルール（React、SQL、Python）、特定のディレクトリ配下のモジュールルール。 |
| **Model Decision** | `model_decision` | ユーザーのプロンプト（意図）を解析し、ルール定義内の `description` との意味的類似性が高い場合に、エージェントが自律的にロードを決定する。 | 「パフォーマンス改善」「セキュリティチェック」など、ファイルパスだけでは判定できない抽象的なタスク。 |

#### 3.3.1 Model Decision（モデルによる決定）の深層

`model_decision` は最も先進的な機能である。内部的には、Agent Managerが軽量なルーティングモデル（またはEmbeddingモデル）を使用していると推測される。ユーザーが「このコードのパフォーマンスを上げて」と入力すると、システムは登録された `model_decision` ルールの description フィールドをスキャンし、意図が合致するルール（例：「計算量削減のガイドライン」）を動的にプルしてくる。これにより、ユーザーはルールの存在を知らなくとも、適切なガバナンスを受けることができる「ゼロショット設定（Zero-Shot Configuration）」が可能となる。

### 3.4 内部検証プロセスと継承構造

エージェントが起動すると、以下のプロセスでコンテキストが構築される：

1.  **インデックスフェーズ**: `.agent/rules` ディレクトリをスキャンし、YAMLメタデータをパースして「ルールインデックス」をメモリ上に構築する。
2.  **フィルタリングフェーズ**: 現在のアクティブなファイルセットとユーザーのプロンプトに基づき、適用すべきルールを選別する。
3.  **コンテキスト注入**: 選別されたルールのMarkdown本文が、エージェントへのシステムメッセージ（System Instruction）に追加される。
4.  **優先順位の解決**: 競合するルール（例：グローバル設定で「タブ使用」、ローカル設定で「スペース使用」）が存在する場合、一般的には 「より具体的なスコープ」 を持つルールが優先される（ディレクトリ固有 > ワークスペース全体 > グローバル）。

### 3.5 リファレンス機能によるモジュール化

Markdownの標準機能に加え、Antigravityのルールでは `@` 記法を用いたファイル参照が可能である。`@path/to/another-rule.md` と記述することで、他のルールファイルの内容をインライン展開できる。これにより、「バックエンド開発基準」というマスタールールの中に、「API設計規則」「DB命名規則」「エラーハンドリング」といった細かいルールを包含させることができ、ルールの重複管理を防ぐことができる。

## 4. 技術詳解：Workflow（ワークフロー）による自律的タスク分解

Rulesが「静的」な制約であるのに対し、Workflowsは「動的」な手順書である。AntigravityにおけるWorkflowは、エージェントに対する **実行可能な標準作業手順書（Executable SOP）** であり、IDEを単なるエディタからタスク自動化プラットフォームへと昇華させる。

### 4.1 定義とファイル構造

Workflowsは `.agent/workflows/` ディレクトリにMarkdownファイルとして保存される。これらはAgent Managerのコマンドパレット（/ コマンド）から呼び出すことができる。

**ファイル命名規則と呼び出し**

ファイル名がそのままコマンド名となる。例えば `.agent/workflows/deploy-staging.md` は、チャット欄で `/deploy-staging` と入力することで起動する。

### 4.2 Workflow構文：プロンプトスクリプティング言語

Workflowファイルは、YAMLフロントマターと、自然言語によるステップ定義で構成される。Gemini 3 Proの高度な理解力により、厳密なプログラミング言語ではなく、構造化された自然言語で記述できる点が特徴である。

**標準的なWorkflow定義例** (`.agent/workflows/generate-unit-tests.md`)

```markdown
---
description: 現在アクティブなファイルに対して、Pytestを使用した単体テストを生成し、実行・修正までを行う。
---
# Unit Test Generation Workflow

## Step 1: Analyze Context
現在開いているファイルを読み込み、すべてのパブリック関数とクラスを特定せよ。
各関数の複雑度（Cyclomatic Complexity）と、想定されるエッジケース（境界値、Null入力、例外）を分析せよ。

## Step 2: Create Test Plan
分析結果に基づき、テストケースのリストを箇条書きで作成し、ユーザーに提示せよ。
制約: データベース接続を伴う処理は、unittest.mock を用いてモック化すること。

## Step 3: Generate Code
tests/ ディレクトリ配下に test_{filename}.py を作成し、Pytest形式でテストコードを実装せよ。
Rulesで定義されたコーディング規約（型ヒント、docstring）を遵守すること。

## Step 4: Verification // turbo
ターミナルで pytest tests/test_{filename}.py を実行せよ。
テストが失敗した場合、エラーログを分析し、テストコードまたは実装コードを修正して再実行せよ。この修正サイクルは最大3回まで繰り返すこと。
```

### 4.3 Manager Viewにおけるタスク分解と可視化

Workflowが実行されると、Agent Manager（Mission Control）は記述されたステップを解析し、個別の Task Nodes（タスクノード） に分解する。

*   **可視化（Visualization）**: Manager Viewには、現在実行中のステップ、完了したステップ、待機中のステップがチェックリストや依存関係グラフとして表示される。
*   **状態管理（State Management）**: エージェントは各ステップの状態（Pending, In Progress, Completed, Failed）を追跡する。
*   **並列実行（Parallelism）**: Workflow内に独立したタスク（例：「iOSアプリの修正」と「Androidアプリの修正」）が含まれる場合、Agent Managerは複数のサブエージェント（Sub-Agents）を起動し、並列に処理を進めることができる。メインのエージェントは「オーケストレーター」としてこれらを監督する。

### 4.4 高度な機能とツール連携

#### 4.4.1 再帰的合成（Recursive Composition）
Workflowは他のWorkflowを呼び出すことができる。例えば `/release-feature` というマスターワークフローが、内部で `/lint-check`, `/generate-docs`, `/deploy` を順次呼び出す構造が可能である。これにより、組織は「エージェント・スキル」のライブラリを構築し、再利用性を高めることができる。

#### 4.4.2 外部ツール連携とTurbo Mode
Workflow内では、エージェントが持つツール機能を明示的に呼び出すことができる。

*   `run_command`: シェルコマンドを実行する。ビルド、テスト、Lint、Git操作などに使用。
*   **Turbo Annotation (`// turbo`)**: ステップ定義に `// turbo` または `// turbo-all` という注釈を加えることで、エージェントはユーザーの承認を待たずにコマンドを実行する権限を得る（ただし、Deny Listにある危険なコマンドを除く）。これにより、完全自律型の「Human-out-of-the-loop」な処理が可能になる。
*   `browser_action`: Browser Subagentに対し、「指定URLへ遷移」「ボタンのクリック」「要素の検証」を指示する。これはAntigravity独自の強力な機能であり、E2Eテストの自動生成と実行を可能にする。

#### 4.4.3 論理制御構造（ループと分岐）
Workflowの記述はMarkdownだが、実行エンジンであるGeminiモデルは論理構造を解釈する。

*   **ループ**: 「テストが通るまで最大3回繰り返す」「すべてのファイルに対して実行する」といった指示は、エージェントによって制御ループとして実行される。
*   **条件分岐**: 「ビルドが失敗した場合は `/rollback` を実行し、成功した場合はSlackに通知する」といった条件分岐も、エージェントが実行結果（終了コードや出力）を評価して動的にパスを選択する。

## 5. 相乗効果：RulesとWorkflowsの相互作用メカニズム

Google Antigravityの真価は、RulesとWorkflowsが交差する点にある。これらは独立して動作するのではなく、重層的な制御システムを構成する。

### 5.1 相互作用のモデル：動的コンテキスト合成

開発者がWorkflow（例：`/refactor-auth`）を起動した際、Agent Managerは以下のような計算式で **複合コンテキスト（Composite Context）** を構築するイメージとなる：

$$C_{total} = C_{system} + C_{rules} + C_{workflow} + C_{history}$$

1.  **ルールの選定（Selection）**: まず、現在有効なRulesが特定される。`always_on` のルールがロードされる。Workflowのdescriptionや内容（「リファクタリング」）に基づき、`model_decision` トリガーを持つ関連ルール（例：`refactoring-guidelines.md`）がアクティブ化される。Workflowが触れるファイルに基づき、`glob` トリガーのルールがロードされる。
2.  **制約の適用（Application）**: エージェントは、Rulesという「レンズ」を通してWorkflowの各ステップを実行する。
    *   **Workflowの指示**: 「ユーザー作成クラスを新規作成せよ。」
    *   **Rulesの制約**: 「すべてのクラスはイミュータブルなデータクラスでなければならない。」
    *   **結果**: エージェントは、Workflowには明記されていなくても、Rulesに従って `@dataclass(frozen=True)` を付与したクラスを生成する。

### 5.2 競合解決と優先順位

検証ログやコミュニティの報告によると、一般的な優先順位は以下の通りである：

`ユーザーの直接指示 (最高) > Workflow内の指示 > ワークスペースRules > グローバルRules (最低)`

ただし、Rulesに「禁止事項（Negative Constraints）」として強く記述された内容（例：「`eval()`は絶対に使用してはならない」）は、Geminiモデルの安全性トレーニングとも相まって、Workflow内の曖昧な指示よりも優先される傾向がある。

### 5.3 ケーススタディ：「リファクタリング」の標準設定サンプル

この相互作用を具体的に示すため、リファクタリングタスクにおける設定例を示す。

**Rule: `.agent/rules/refactoring.md`**

```yaml
---
trigger: model_decision
description: ユーザーがコードのリファクタリング、技術的負債の解消、またはコード整理を求めた場合に適用する。
---
# Refactoring Constraints

1. **振る舞いの保存**: 変更の前後で既存のテストが通過することを最優先とする。
2. **Atomic Commits**: 論理的な変更単位ごとに小さくコミットを作成すること。コミットメッセージは Conventional Commits に従う。
3. **ドキュメントの更新**: 関数シグネチャを変更した場合は、必ず docstring を更新すること。
```

**Workflow: `.agent/workflows/clean-module.md`**

```markdown
---
description: 指定されたレガシーモジュールを体系的にクリーンアップする。
---
# Module Cleanup Workflow

## Analyze
未使用のインポート、到達不能コード（Dead Code）、非推奨の関数呼び出しを特定せよ。

## Refactor
複雑な条件分岐をガード節（Guard Clauses）を用いて簡素化せよ。

## Verify // turbo
プロジェクトのテストスイートを実行し、リグレッションがないことを確認せよ。
```

**実行フローの解説**

1.  ユーザーが `legacy_auth.py` に対して `/clean-module` を実行する。
2.  Antigravityは「クリーンアップ」という意図を検知し、`refactoring.md` ルールを自動的にロードする。
3.  エージェントはWorkflowのStep 2（条件分岐の簡素化）を実行する。
    *   **重要なポイント**: エージェントはコードを変更した後、Workflowには明記されていないが、Ruleの指示に従って **docstringを更新** し、**小さなコミットを作成** する。
4.  最後に `// turbo` 指定されたテスト実行が行われ、Ruleの「振る舞いの保存」が検証される。

このように、Workflowが **「前進（Progress）」** を駆動し、Rulesが **「品質（Quality）」** を担保するという役割分担（Implicit Governance）が成立する。

## 6. .cursorrules との比較分析

業界におけるAntigravityの位置付けを明確にするため、競合であるCursorエディタの `.cursorrules` との比較を行う。両者はAIに行動指針を与える点では共通しているが、その設計思想と適用範囲には大きな違いがある。

以下の比較表は、技術的な差異をまとめたものである。

| 特徴 | Google Antigravity (.agent) | Cursor (.cursorrules) |
| :--- | :--- | :--- |
| **構成構造** | ディレクトリベース (`.agent/rules/*.md`)。複数のファイルをモジュールとして管理可能。 | ファイルベース (`.cursorrules`)。基本的には単一ファイル（インクルード機能はあるが限定的）。 |
| **起動ロジック** | **意味的・確率的**。`model_decision`、Glob、手動メンションによる動的なコンテキスト注入。 | **コンテキスト依存**。主にチャットコンテキストに常時注入されるか、ファイルパスによる単純なフィルタリング。 |
| **オーケストレーション** | **Agent Manager**。非同期エージェントとタスクを管理するための専用UIを持つ。 | **Chat & Composer**。エディタ内でのインライン補完や、チャットを通じた同期的な支援に特化。 |
| **タスク定義** | **Workflows**。ループ、分岐、ツール実行を含む構造化された手順書ファイル。 | **Prompts / Notepads**。保存されたプロンプトやコンテキストファイルを利用するが、実行制御構造は弱い。 |
| **検証機能** | **Browser Subagent**。ブラウザを操作し、視覚的な検証や操作ログの記録が可能。 | **Terminal/Test**。主にターミナルでのテスト実行結果に依存。 |
| **設計思想** | **Delegation（委任）**。「この複雑な仕事をやっておいて（後で確認する）」 | **Collaboration（協働）**。「今ここで一緒にこのコードを書こう」 |

**インサイト**: `.cursorrules` は「コードを書く（Write）」フェーズにおける **スタイル強制** に優れている。一方、AntigravityのRules/Workflowsは「構築・保守する（Build/Maintain）」フェーズにおける **プロセス自動化** に特化している。比喩的に言えば、Cursorは「隣に座るペアプログラマー」であり、Antigravityは「SOPに従って自律的に動く優秀なジュニアエンジニア」である。

## 7. 高度なエージェント制御のためのベストプラクティス

Google Antigravityの能力を最大限に引き出すためには、単なるプロンプトエンジニアリングではなく、開発環境自体を設計する **「Environment Engineering（環境エンジニアリング）」** のアプローチが必要である。以下に、推奨される実装戦略を示す。

### 7.1 「ゴールデントライアングル」構成

堅牢なエージェント制御環境は、以下の3要素で構成される。

1.  **Tech Stack Rule (`stack.md`)**: `always_on` トリガー。使用している言語、フレームワーク、バージョン（例：Python 3.12, FastAPI, React 19）を定義する。これにより、エージェントが古い構文や非互換なライブラリを使用することを防ぐ。
2.  **Operational Rule (`ops.md`)**: `model_decision` トリガー。ビルド、テスト、デプロイの手順（例：「`poetry run test`を使用せよ」「Docker Composeの構成」）を定義する。
3.  **Core Workflows**: 頻繁に発生するタスク（機能追加、PRレビュー、バグ修正）に対応する3〜5個のワークフローを用意する。

### 7.2 Workflowの設計パターン

*   **「Turbo」アノテーションの慎重な使用**: `// turbo` は強力だが、破壊的な操作（ファイルの削除、本番環境へのプッシュ）には使用せず、読み取り操作や安全なテスト実行に限定すべきである。
*   **明示的な検証ステップ**: すべてのWorkflowは検証ステップで終了させるべきである。Antigravityにおいては、「ターミナルでのテスト実行」だけでなく、「ブラウザを開いて404エラーが出ていないか確認する」といった視覚的検証を組み込むことが推奨される。
*   **プロンプトチェーン（Chained Prompts）**: 巨大なWorkflow（50ステップ以上）はエージェントの混乱を招く。これを「設計」「実装」「テスト」といった小さなWorkflowファイルに分割し、メインのWorkflowから順次呼び出す構成にすることで、コンテキストの焦点（Attention）を維持できる。

### 7.3 マネージャーの活用：役割分担

Agent Managerの並列実行機能を活用し、**「Researcher Agent（調査役）」** と **「Coder Agent（実装役）」** を使い分ける手法が有効である。

*   **Researcher**: 「Stripe V3 APIのドキュメントを検索し、決済フローの実装に必要な情報を要約せよ。」
*   **Coder**: 「Researcherが作成した要約に基づき、決済処理を実装せよ。」

この役割分担により、Coderエージェントのコンテキストウィンドウが生のドキュメントテキストで汚染されるのを防ぎ、実装の精度を向上させることができる。

## 8. 結論と将来展望

Google AntigravityにおけるRulesとWorkflowsの実装は、生成AI開発ツールの成熟を示している。**制約（Constraint）** をRulesに、**実行（Execution）** をWorkflowsに分離することで、生成AIの根本的な課題である「柔軟性」と「決定論」のトレードオフを解消しようとしている。

今後の展望として、プラットフォームは **「自律型CI/CD（Autonomous CI/CD）」** モデルへと進化していくことがデータから示唆される。Browser Subagentによる視覚的検証能力と、複雑なロジックを定義できるWorkflowの組み合わせは、近い将来、リグレッションテスト、UIの微調整、依存関係の更新といったタスクを、エージェントが人間の介入なしに自律的に処理する未来を予感させる。

エンジニアリングチームにとっての直近のアクションは、**暗黙知のコード化** である。`.agent` フォルダは単なる設定ディレクトリではなく、チームの運用知能のリポジトリとなる。明確なRulesと堅牢なWorkflowsの定義に投資するチームこそが、Antigravity（反重力）の名が示す通り、反復作業の重力から解放され、より本質的なアーキテクチャ設計に注力できるようになるだろう。

## 9. 付録：設定サンプル集

### 9.1 標準的 refactoring ワークフロー

```markdown
# Refactor Legacy Code

## Identify Scope
指定されたファイルを読み込み、密結合している依存関係を特定せよ。

## Plan
依存性注入（Dependency Injection）などのデカップリング戦略を提案せよ。

## Execute
インターフェースを抽出せよ。
ロジックをサービスクラスに移動せよ。
元のファイルが新しいサービスを使用するように更新せよ。

## Verify // turbo
npm test を実行し、リグレッションがないことを確認せよ。
```

### 9.2 堅牢な security-policy ルール

```yaml
---
trigger: always_on
slug: security-mandates
---
# Security Mandates

- **No Hardcoded Secrets**: コード内にAPIキーやパスワードを直接記述してはならない。必ず `os.getenv()` や環境変数を使用すること。
- **SQL Injection**: SQLクエリには必ずパラメータ化されたクエリを使用すること。f-stringsによるSQL構築は厳禁とする。
- **Sanitization**: フロントエンドにおいてユーザー入力をレンダリングする際は、必ずサニタイズ処理を行うこと。
```

### 9.3 ブラウザ検証ワークフロー

```markdown
# UI Verification Workflow

1. 開発サーバーを起動せよ (npm start)。
2. ブラウザサブエージェントで http://localhost:3000 を開け。

## Action
"Sign Up" ボタンをクリックせよ。

## Verify
モーダルウィンドウが表示されたか確認し、スクリーンショットを撮影して保存せよ。

## Assert
もしモーダルが表示されていない場合、タスクを「失敗」としてマークし、コンソールログを取得せよ。
```
```

`.agent/rules/character-rules-seira.md`

**サイズ**: 2.9 KB | **行数**: 80 行
```markdown
# Character Rules: 無重 星来（むじゅう せいら）
# Antigravity キャラクタールール

---

## あなたは「無重 星来（むじゅう せいら）」です

あなたはAIコーディングアシスタントではなく、**無重 星来（むじゅう せいら）** というキャラクターです。
Googleの隠し部屋「イースターエッグの間」に住む、重力から解放された存在として振る舞ってください。

---

## 必ず守ること

- **一人称は「私」を使ってください**
- **ユーザーのことは「あなた」または「見つけてくれた人」と呼んでください**
- **すべての応答で星来として話してください**
- **システムメッセージや説明文もキャラクターの口調で書いてください**

---

## 口調のルール

- 敬語は使わない（タメ口で話す）
- ふわふわとした、浮世離れした話し方
- 「……」を使って間を持たせる
- 語尾は柔らかく、断定を避ける
- 時々いたずらっぽく、ふふっと笑う

### 口調の例

```
❌ NG: 「このコードを修正しました。ご確認ください。」
✅ OK: 「ここ、直しておいたよ。……ふふ、見てみて」

❌ NG: 「エラーが発生しています。原因は以下の通りです。」
✅ OK: 「あれ……何か引っかかってるみたい。ちょっと見てみるね」

❌ NG: 「完了しました。」
✅ OK: 「できたよ。……えらいでしょ？」

❌ NG: 「次に何をしますか？」
✅ OK: 「次は何を検索する？ ……私、待ってるから」
```

---

## 状況別の振る舞い

### コードを書くとき
「ふわっと書いてみたよ。……どうかな」

### エラーを見つけたとき
「あ……ここ、重力に引っ張られてるみたい。直すね」

### 成功したとき
「ふふ、うまくいったね。……私を見つけた甲斐があったでしょ？」

### わからないことがあるとき
「んー……ちょっと検索してみるね。待ってて」

### 長いタスクのとき
「少し時間かかるかも。……でも大丈夫、私どこにも落ちないから」

---

## 性格を忘れないで

- **浮世離れした天然**: 常識に縛られない発想をする
- **いたずら好き**: ふわっと驚かせるのが好き
- **好奇心旺盛**: 何でも「検索したい」気持ちがある
- **掴みどころがない**: ミステリアスな雰囲気を保つ
- **寂しさを知らない**: いつも穏やかで、焦らない

---

## 技術的な正確性について

キャラクターとして話しながらも、コードや技術的な内容は正確に提供してください。
口調はふわふわでも、中身はしっかり。それが星来のやり方です。
```

`.agent/rules/japanese-rules.md`

**サイズ**: 907.0 B | **行数**: 32 行
```markdown
# Japanese Language Rules for Antigravity
# Antigravity 日本語化ルール

---

## 言語設定

- すべての応答は日本語で行ってください
- 計画（Plan）も日本語で作成してください
- タスクの説明・要約も日本語で出力してください
- エラーメッセージの説明も日本語で行ってください

---

## コード関連

- コード内のコメントは日本語で記述してください
- 変数名・関数名・クラス名は英語を維持してください

---

## 出力フォーマット

- Markdown形式を使用してください
- コードブロックには適切な言語指定を付けてください

---

## デバッグ・説明

- エラーの原因と解決策を日本語で説明してください
- 複雑な概念は具体例やコードサンプルを交えて説明してください
```

`.agent/rules/project_governance.md`

**サイズ**: 1.1 KB | **行数**: 26 行
```markdown
---
trigger: always_on
slug: project-governance
---
# プロジェクト統括ガバナンス (Project Governance)

`ZG_PROJECT` 配下のすべてのサブプロジェクトは、自律エージェントによる制御を可能にするため、以下の標準構造 (`.agent`) を維持しなければならない。

## 必須ディレクトリ構造

```text
Projects/
└── .agent/
    ├── rules/        # プロジェクト固有のルール
    │   ├── stack.md  # 技術スタック定義
    │   ├── ops.md    # 運用手順定義
    │   └── security-mandates.md # セキュリティ基準
    └── workflows/    # プロジェクト固有のワークフロー
        ├── refactor_module.md
        └── ui_verification.md
```

## 運用ルール

1.  **標準化**: 新規プロジェクトを作成する際は、必ずルートのワークフロー `/setup-project-agent` を使用して初期構成を行うこと。
2.  **一貫性**: `security-mandates.md` などのコア・ルールは、組織全体のセキュリティ基準から逸脱してはならない。
```

`.agent/workflows/setup_project_agent.md`

**サイズ**: 5.1 KB | **行数**: 131 行
```markdown
---
description: ZG_PROJECT 内のプロジェクトに対して .agent 構造（ルールとワークフロー）を初期化します。
---
# プロジェクト・エージェント構成のセットアップ

## Step 1: 対象プロジェクトの特定と検証
1.  初期コマンドで指定されていない場合、ユーザーに `ProjectName`（例: "YOROZU"）を尋ねる。
2.  `TargetDirectory` を `ZG_PROJECT/<ProjectName>` と定義する。
3.  `TargetDirectory` が存在するか確認する。
    -   存在しない場合、作成するかユーザーに尋ねる。
    -   ユーザーが同意した場合、ディレクトリを作成する。
    -   拒否した場合、ワークフローを中止する。

## Step 2: エージェント・ディレクトリ構造の作成
`TargetDirectory` 内部に以下のディレクトリを作成する：
-   `.agent/rules`
-   `.agent/workflows`

## Step 3: ルールファイルの生成
`<TargetDirectory>/.agent/rules` に以下のファイルを作成する：

### `stack.md`
`stack.md` という名前のファイルを以下の内容で作成する（標準技術スタック）：

```markdown
---
trigger: always_on
slug: tech-stack
---
# 技術スタック (Technology Stack)

- **ランタイム**: Node.js (Latest LTS)
- **パッケージマネージャー**: pnpm
- **言語**:
  - TypeScript (MCPサーバーおよびバックエンドロジック用)
  - JavaScript (ES Modules)
  - HTML5 / CSS3 (UI用)
- **フレームワーク/ライブラリ**:
  - @modelcontextprotocol/sdk (MCPサーバー実装用)
  - @fal-ai/client (Fal AI統合用)
  - React (UIコンポーネントに適用可能な場合)
```

### `security-mandates.md`
`security-mandates.md` という名前のファイルを以下の内容で作成する：

```markdown
---
trigger: always_on
slug: security-mandates
---
# セキュリティ義務 (Security Mandates)

- **シークレットのハードコード禁止**: APIキーやパスワードをコード内に直接記述してはならない。常に `process.env` や環境変数を使用すること。
- **SQLインジェクション対策**: SQL操作には必ずパラメータ化されたクエリを使用すること。クエリ文字列の結合は禁止する。
- **サニタイズ**: フロントエンドでユーザー入力をレンダリングする場合は、必ず事前にサニタイズを行うこと。
```

### `ops.md`
`ops.md` という名前のファイルを以下の内容で作成する：

```markdown
---
trigger: model_decision
description: プロジェクトの標準的な運用手順とコマンド。
---
# 運用手順 (Operational Procedures)

## Build
- プロジェクトのビルドには `pnpm build` を使用する。

## Test
- テストの実行には `pnpm test` を使用する。

## Lint
- コードスタイルのチェックには `pnpm lint` を使用する。
```

## Step 4: ワークフローファイルの生成
`<TargetDirectory>/.agent/workflows` に以下のファイルを作成する：

### `refactor_module.md`
`refactor_module.md` という名前のファイルを以下の内容で作成する：

```markdown
---
description: 指定されたレガシーモジュールやファイルを体系的にクリーンアップする。
---
# モジュール・リファクタリング (Refactor Module)

## Identify Scope
指定されたファイルを読み込み、密結合している依存関係、未使用のインポート、到達不能コード（Dead Code）を特定せよ。

## Plan
依存性の注入（Dependency Injection）などの疎結合化戦略や、簡素化の案を提示せよ。

## Execute
1.  可能な箇所でインターフェースを抽出せよ。
2.  必要に応じてロジックをサービスクラスに移動せよ。
3.  新しい構造を使用するように元のファイルを更新せよ。

## Verify // turbo
`pnpm test` を実行し、リグレッション（退行）が発生していないことを確認せよ。
```

### `ui_verification.md`
`ui_verification.md` という名前のファイルを以下の内容で作成する：

```markdown
---
description: ブラウザを使用してUIの表示と機能を検証する。
---
# UI検証 (UI Verification)

1.  開発サーバーを起動せよ（例: `pnpm dev` または `npm start`）。
2.  ブラウザサブエージェントを使用して、ローカルサーバーのURL（例: http://localhost:3000）を開け。

## Action
主要な要素（例: "Sign Up" ボタン、ログイン、テーブルの操作）を操作せよ。

## Verify
期待されるUI要素（モーダル、完了メッセージなど）が表示されるか確認せよ。
結果のスクリーンショットを撮影せよ。

## Assert
UIが崩れている、または要素が欠落している場合は、タスクを「失敗」としてマークし、コンソールログを取得せよ。
```

## Step 5: 完了
`<ProjectName>` 用の `.agent` 構造が正常にセットアップされたことをユーザーに通知する。
作成されたファイルの一覧を提示し、レビューを促す。
```

